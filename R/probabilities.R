#' Probability prediction functions.
#'
#' Functions to be used to generate the prediction functions/matrices.
#'
#' @param scores A square matrix of pair-wise scores.
#' @param annotations A list of annotations, such as that generated by
#'    [cleanAnnotations()].
#' @param highScoreIsBest Whether the score is one where higher values represent
#'    better scores. An example of when this is true would be the Jaccard
#'    coefficient, and false would be P-values (though it is strongly recommended
#'    to `-log10()` transform P-values in order to obtain a linear range of scores).
#' @param merged The output of [mergeScoresAndAnnotations()].
#' @param maxProb What is the max possible predicted probability? If the
#'    available scores do not predict anywhere near 100%, it may be worthwhile
#'    manually lower this to a more sensible value as to not generate
#'    overly-optimistic predictions.
#' @param useMeanSmoothing Whether to smooth the probability function/matrix
#'    using moving-window mean smoothing.
#' @param windowSize The window size for moving-window mean smoothing.
#' @param df1 The first set of scores, as generated by [mergeScoresAndAnnotations()].
#' @param df2 The second set of scores, as generated by [mergeScoresAndAnnotations()].
#' @param len1 The number of intervals of use in the final prediction matrix,
#'    corresponding to the first set of scores.
#' @param len2 The number of intervals of use in the final prediction matrix,
#'    corresponding to the second set of scores.
#' @param lims1 The min and max values possible for the first set of scores.
#'    By default, this is detected from the min and max values of the input,
#'    but it can be manually set if the input data does not represent the full
#'    possible range.
#' @param lims2 The min and max values possible for the second set of scores.
#'    By default, this is detected from the min and max values of the input,
#'    but it can be manually set if the input data does not represent the full
#'    possible range.
#' @param bw1Match The bandwidth value used by [KernSmooth::bkde2D()] for the
#'    subset of the first set of scores which represent an annotation match.
#' @param bw1NoMatch The bandwidth value used by [KernSmooth::bkde2D()] for the
#'    subset of the first set of scores which do not represent an annotation match.
#' @param bw2Match The bandwidth value used by [KernSmooth::bkde2D()] for the
#'    subset of the second set of scores which represent an annotation match.
#' @param bw2NoMatch The bandwidth value used by [KernSmooth::bkde2D()] for the
#'    subset of the second set of scores which do not represent an annotation match.
#' @param CombinedDf The out of [getProbMatchDfDouble()].
#' @param windowSize1 The window size for moving-window mean smoothing, for the
#'    first set of scores.
#' @param windowSize2 The window size for moving-window mean smoothing, for the
#'    second set of scores.
#' @param scores1 The first set of scores to use for prediction.
#' @param scores2 The second set of scores to use for prediction.
#' @param predFUN The prediction function as generated by [getProbMatchFunSingle()].
#' @param predMatrix The prediction matrix as generated by
#'    [getProbMatchMatrixDouble()].
#'
#' @return
#'    For [mergeScoresAndAnnotations()]: The input score matrix is converted to
#'    `data.frame` with pair-wise scores, keeping only families which have
#'    associated annotation. An additional logical column indicates the presence
#'    of a matching annotation between the pairs.
#'
#'    For [getProbMatchFunSingle()]: A function which can be used to predict
#'    the probability of a matching annotation/function using the input scoring
#'    method.
#'
#'    For [getProbMatchDfDouble()]: A `data.frame` with `x` and `y` coordinates
#'    for the annotation/function prediction matrix, which associated
#'    probability data.
#'
#'    For [getProbMatchMatrixDouble()]: A matrix of probabilities which can be
#'    used to predict the probability of a annotation/function match based on
#'    two input scores.
#'
#'    For [calcMatchingProbsSingle()], [calcMatchingProbsDouble()]: A matrix of
#'    probabilities of matching annotation/function based on the input score.
#'
#' @author Benjamin Jean-Marie Tremblay, \email{b2tremblay@@uwaterloo.ca}
#' @name ProbabilityFunctions

#' @rdname ProbabilityFunctions
#' @export
mergeScoresAndAnnotations <- function(scores, annotations, highScoreIsBest = TRUE) {
  scores <- as.matrix(scores)
  rownames(scores) <- colnames(scores)
  scores <- scores[rownames(scores) %in% names(annotations),
      colnames(scores) %in% names(annotations)]
  scores[upper.tri(scores)] <- NA
  diag(scores) <- NA
  scores2 <- melt(scores, na.rm = TRUE)
  colnames(scores2) <- c("Fam1", "Fam2", "Score")
  scores2$Anno1 <- annotations[scores2$Fam1]
  scores2$Anno2 <- annotations[scores2$Fam2]
  scores2$MatchingAnno <- mapply(function(x, y) any(x %in% y),
      scores2$Anno1, scores2$Anno2)
  scores2
}

#' @rdname ProbabilityFunctions
#' @export
getProbMatchFunSingle <- function(merged, highScoreIsBest = TRUE, maxProb = 1,
  useMeanSmoothing = FALSE, windowSize = max(1, round(0.0001 * nrow(merged)))) {
  if (anyNA(merged$Score))
    stop("Found NA values in Score column")
  if (any(is.infinite(merged$Score)))
    stop("Found non-finite values in score column")
  merged <- merged[order(merged$Score, decreasing = highScoreIsBest), ]
  merged$CumProbMatch <- cumsum(merged$MatchingAnno) / 1:nrow(merged)
  ProbMatch <- merged$CumProbMatch
  Scores <- merged$Score
  if (useMeanSmoothing) {
    ProbMatch <- as.vector(stats::filter(ProbMatch, rep(1 / windowSize, windowSize),
      sides = 2))
    Scores <- Scores[!is.na(ProbMatch)]
    ProbMatch <- ProbMatch[!is.na(ProbMatch)]
  }
  if (highScoreIsBest)
    approxfun(Scores, ProbMatch, yleft = 0, yright = maxProb)
  else
    approxfun(Scores, ProbMatch, yleft = maxProb, yright = 0)
}

#' @rdname ProbabilityFunctions
#' @export
getProbMatchDfDouble <- function(df1, df2, len1 = 21, len2 = 21,
  lims1 = range(df1$Score), lims2 = range(df2$Score),
  bw1Match = MASS::bandwidth.nrd(df1$Score[df1$MatchingAnno]) * 2,
  bw1NoMatch = MASS::bandwidth.nrd(df1$Score[!df1$MatchingAnno]) * 2,
  bw2Match = MASS::bandwidth.nrd(df2$Score[df2$MatchingAnno]) * 2,
  bw2NoMatch = MASS::bandwidth.nrd(df2$Score[!df2$MatchingAnno]) * 2) {

  df1$Score[df1$Score > lims1[2]] <- lims1[2]
  df1$Score[df1$Score < lims1[1]] <- lims1[1]
  df2$Score[df2$Score > lims2[2]] <- lims2[2]
  df2$Score[df2$Score < lims2[1]] <- lims2[1]

  dfTrue <- as.matrix(cbind(df1$Score[df1$MatchingAnno],
      df2$Score[df2$MatchingAnno]))
  dfFalse <- as.matrix(cbind(df1$Score[!df1$MatchingAnno],
      df2$Score[!df2$MatchingAnno]))

  seq1 <- seq(from = lims1[1], to = lims1[2], length.out = len1)
  seq2 <- seq(from = lims2[1], to = lims2[2], length.out = len2)

  binsTrue1 <- cut(dfTrue[, 1], seq1, include.lowest = TRUE)
  binsTrue2 <- cut(dfTrue[, 2], seq2, include.lowest = TRUE)
  binsFalse1 <- cut(dfFalse[, 1], seq1, include.lowest = TRUE)
  binsFalse2 <- cut(dfFalse[, 2], seq2, include.lowest = TRUE)

  kernTrue <- bkde2D(dfTrue, c(bw1Match, bw2Match), c(len1, len2),
    list(lims1, lims2))
  kernFalse <- bkde2D(dfTrue, c(bw1NoMatch, bw2NoMatch), c(len1, len2),
    list(lims1, lims2))

  kernTrueNorm <- (kernTrue$fhat / sum(kernTrue$fhat)) * nrow(dfTrue)
  kernFalseNorm <- (kernFalse$fhat / sum(kernFalse$fhat)) * nrow(dfFalse)

  kernRatio <- matrix(kernTrueNorm / (kernFalseNorm + kernTrueNorm),
    nrow(kernTrue$fhat), dimnames = list(seq1, seq2))

  dfPMF <- expand.grid(x = seq1, y = seq2)

  xInd <- match(as.character(dfPMF$x), rownames(kernRatio))
  yInd <- match(as.character(dfPMF$y), colnames(kernRatio))

  kernRatio[is.na(kernRatio)] <- 0
  kernRatioVec <- as.vector(kernRatio)
  kernRatioVec[is.na(kernRatioVec)] <- 0
  kernTrueNormVec <- as.vector(kernTrueNorm)
  kernFalseNormVec <- as.vector(kernFalseNorm)

  TFcounts <- calcCounts(xInd, yInd, kernRatio, kernRatioVec, kernTrueNormVec,
    kernFalseNormVec)

  dfPMF$CountTrue <- TFcounts$Tcount
  dfPMF$CountFalse <- TFcounts$Fcount
  dfPMF$CountTotal <- dfPMF$CountTrue + dfPMF$CountFalse
  dfPMF$MatchProb <- dfPMF$CountTrue / dfPMF$CountTotal

  dfPMF <- dfPMF[order(dfPMF$CountTotal, dfPMF$MatchProb), ]

  dfPMF

}

calcCounts <- function(xInd, yInd, kernRatio, kernRatioVec,
  kernTrueNormVec, kernFalseNormVec) {
  Tcounts <- Fcounts <- numeric(length(kernRatioVec))
  for (i in seq_len(length(kernRatioVec))) {
    rInd <- kernRatioVec >= kernRatio[xInd[i], yInd[i]]
    Tcounts[i] <- sum(kernTrueNormVec[rInd])
    Fcounts[i] <- sum(kernFalseNormVec[rInd])
  }
  list(Tcount = Tcounts, Fcount = Fcounts)
}

#' @rdname ProbabilityFunctions
#' @export
getProbMatchMatrixDouble <- function(CombinedDf, useMeanSmoothing = FALSE,
  windowSize1 = 3, windowSize2 = 3) {
  CombinedMatrix <- acast(CombinedDf, x ~ y, value.var = "MatchProb")
  if (useMeanSmoothing) {
    CombinedRaster <- raster(CombinedMatrix)
    CombinedSmoothed <- as.matrix(focal(CombinedRaster,
        matrix(1, windowSize1, windowSize2), mean, pad = FALSE))
    dimnames(CombinedSmoothed) <- dimnames(CombinedMatrix)
    CombinedMatrix <- CombinedSmoothed
  }
  CombinedMatrix
}

#' @rdname ProbabilityFunctions
#' @export
calcMatchingProbsSingle <- function(scores, predFUN) {
  scores <- as.matrix(scores)
  rownames(scores) <- colnames(scores)
  diag(scores) <- NA
  matrix(predFUN(scores), nrow = nrow(scores), dimnames = dimnames(scores))
}

#' @rdname ProbabilityFunctions
#' @export
calcMatchingProbsDouble <- function(scores1, scores2, predMatrix) {
  cuts1 <- as.numeric(rownames(predMatrix))
  cuts1 <- c(-Inf, cuts1[-1] - diff(cuts1) / 2, Inf)
  cuts2 <- as.numeric(colnames(predMatrix))
  cuts2 <- c(-Inf, cuts2[-1] - diff(cuts2) / 2, Inf)
  scores1 <- as.matrix(scores1)
  scores2 <- as.matrix(scores2)
  rownames(scores1) <- colnames(scores1)
  rownames(scores2) <- colnames(scores2)
  scores1[upper.tri(scores1)] <- NA
  diag(scores1) <- NA
  scores2[upper.tri(scores2)] <- NA
  diag(scores2) <- NA
  scores1 <- melt(scores1, na.rm = TRUE)
  scores2 <- melt(scores2, na.rm = TRUE)
  ind1 <- findInterval(scores1[[3]], cuts1)
  ind2 <- findInterval(scores2[[3]], cuts2)
  answer <- data.frame(Fam1 = scores1[[1]], Fam2 = scores1[[2]],
    PMF = predMatrix[cbind(ind1, ind2)])
  out <- acast(answer, Fam1 ~ Fam2, value.var = "PMF")
  diag(out) <- NA
  outt <- t(out)
  out[upper.tri(out)] <- outt[upper.tri(outt)]
  out
}
